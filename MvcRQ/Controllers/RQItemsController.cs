using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using MvcRQ.Models;
using MvpRestApiLib;
using System.Web.UI;

using RQLib.RQQueryForm;
using MvcRQ.Helpers;

namespace MvcRQ.Controllers
{
    /// <summary>
    /// Controller Class for URLs designating RQItem objects
    /// </summary>
    /// <remarks>
    /// The controller supports URLs of type 
    /// {serviceId}RQItems/{RQItemId}
    /// </remarks>
    public class RQItemsController : BaseController
    {
        #region private methods

        /// <summary>
        /// Returns a collection of RQItems pertainig to a given query. 
        /// </summary>
        /// <remarks>
        /// A RQQuery structure is generated from the given query string. The default properties of RQQuery have to be set in advance.
        /// The query result is retrieved from the server-side cache, if one has already been stored under the same query string 
        /// </remarks>
        /// <param name="queryString">
        /// A query string input conforming to Riquest query syntax.  
        /// </param>
        /// Allows model records to be edited.
        /// <param name="forEdit">
        /// </param>
        /// <returns>
        /// The RQItemModel with RQItems property containing the result list. 
        /// </returns>
        private RQItemModel GetModel(RQquery query, bool forEdit)
        {
            RQItemModel rqitemModel = base.HttpContext.Cache[query.QueryString.ToLower()] as RQItemModel;

            if ( (rqitemModel == null) || (forEdit == true) )
            {
                if (query.QueryBookmarks == false)
                    query.QueryBookmarks = true;
                rqitemModel = new RQItemModel(query, forEdit);
                base.HttpContext.Cache[query.QueryString.ToLower()] = rqitemModel;
            }
            return rqitemModel;
        }

        private RQItemModel GetModel(RQquery query)
        {
            return GetModel(query, false);
        }

        private RQquery NewQuery(string queryString, Helpers.StateStorage.States  stateType)
        {
            return Helpers.StateStorage.GetQueryFromState(queryString, stateType);
        }

        private RQquery GetQuery(Helpers.StateStorage.States stateType)
        {
            return Helpers.StateStorage.GetQueryFromState("", stateType);
        }

        private string TransformModel(RQItemModel model, string format, int fromItem, int toItem)
        {
            System.Xml.XmlTextReader r = model.RQItems.ConvertTo(format, fromItem, toItem);

            try
            {
                var xTrf = new System.Xml.Xsl.XslCompiledTransform();
                var xTrfArg = new System.Xml.Xsl.XsltArgumentList();
                var mstr = new System.Xml.XmlTextWriter(new System.IO.MemoryStream(), System.Text.Encoding.UTF8);
                var doc = new System.Xml.XmlDocument();

                r.MoveToContent();
                xTrf.Load(Server.MapPath("~/xslt/ViewTransforms/RQResultList2RQSorted.xslt"));
                xTrfArg.AddParam("ApplPath", "", "http://" + Request.ServerVariables.Get("HTTP_HOST") + (Request.ApplicationPath.Equals("/") ? "" : Request.ApplicationPath));
                xTrf.Transform(new System.Xml.XPath.XPathDocument(r), xTrfArg, mstr);
                mstr.BaseStream.Flush();
                mstr.BaseStream.Seek(0, System.IO.SeekOrigin.Begin);
                doc.Load(mstr.BaseStream);

                //TESTDATEI EZEUGEN
                //doc.Save("C:/MVCTest.xml");
                //mstr.BaseStream.Seek(0, System.IO.SeekOrigin.Begin);

                var rd = new System.Xml.XmlTextReader(mstr.BaseStream);
                return doc.OuterXml;
            }
            catch
            {
                // RQItemSet ist leer
                return "";
            }
        }
        
        #endregion

        #region public actions

        /// <summary>
        /// Controller action answering GET http-requests to RQItems
        /// </summary>
        /// <remarks>
        /// The action reacts to URLs of type "~/RQItems" | "~/{serviceId}/RQItems".
        /// The action response is filtered by the ActionFilterAttributes "EnableJson" and "EnableXml":
        /// If the GET request contains dataType=application/json | text/json or dataType=application/xml | text/xml 
        /// the action response is generated by class "JsonResult2" or "XmlResult" of "MvpRestApiLib".
        /// In both cases the client is responsible to render the xml (f. e. by XSLT).
        /// Otherwise the action response is transformed to text/html on the server according to the value of parameters "verb" or "serviceId" respectively. 
        /// </remarks>
        /// <param name="verb">
        /// null | New | rqListHTML.
        /// </param>
        /// <param name="queryString">
        /// </param>
        /// <param name="serviceId">
        /// Id of requested sercive API:
        /// "rqi" = internal RiQuest API (default);
        /// "rq" = RiQuest proprietary exchange format;
        /// "mods" = Metadata Object Description Format (MODS) API of the Library of Congress (not yet supported);
        /// "oai_dc" = Dublin Core(DC) API serving metadata according to the specification of Open Archives Initiative (OAI);
        /// "srw_dc" = Dublin Core(DC) API serving metadata according to the specification of the Search / Retrieve Web Service (SRW) (not yet supported);
        /// "info_ofi" = OpenURL API (not yet supported);
        /// "pubmed" = API serving metadata according to the PubMed metadata scheme (not yet supported).
        /// </param>
        /// <returns>
        /// verb == null: 
        ///     The action returns the (empty) RQItems/Index view.
        /// verb == New: 
        ///     The action returns an (empty) data entry mask to add a new RQItem.
        /// verb == rqListHTML: 
        ///     The action returns a collection of RQItems 
        ///     as */json, */xml or text/html - the latter generated by the XSLT "RQResultList2RQSorted.xslt" - 
        ///     depending on data types specified in the GET request.
        /// serviceId = rq | rqi | mods | oai_dc | srw_dc | info_ofi | pubmed: 
        ///     The action returns a collection of RQItems formatted according to the requested service API 
        ///     as */json, */xml or text/html - the latter generated by the XSLT "RQResultList2RQSorted.xslt" - 
        ///     depending on data types specified in the GET request. 
        /// The returned collection is the result set pertaining to the query set in parameter queryString, the last query stored in the state storage or  
        ///  - if both are void - to the "recent additions" query. 
        /// </returns>
        [EnableJson, EnableXml]
        [HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        public ActionResult RQItemList(string verb, string queryString, string serviceId)
        {
            if ((!string.IsNullOrEmpty(verb)) && ((verb.ToLower() == "new") || (verb == RQResources.Views.Shared.SharedStrings.add)))
            {
                ViewBag.EditButton1 = RQResources.Views.Shared.SharedStrings.add;
                ViewBag.EditButton2 = RQResources.Views.Shared.SharedStrings.cancel;
                return View("EditRQItem", new RQItem());
            }
            else if (verb == "rqListHTML")
            {
                StateStorage.States viewState = (!string.IsNullOrEmpty(queryString) && (queryString.StartsWith("$class$") == true)) ? StateStorage.States.BrowseViewState : StateStorage.States.ListViewState; 
                return this.Content(TransformModel(GetModel(queryString == null ? GetQuery(viewState) : NewQuery(queryString, viewState)), verb, 1, 0), "text/html", System.Text.Encoding.UTF8);
            }
            else if (serviceId != null)
            {
                ViewBag.ServiceType = serviceId;
                ViewBag.TextSeg0 = "a list of RQItems";
                switch (serviceId)
                {
                    case "mods":
                        throw new NotImplementedException("RiQuest data service not yet implemented for mods format.");
                    case "oai_dc":
                        EnableXmlAttribute.XSLTransform = "~/xslt/rqi2dc.xslt";
                        break;
                    case "srw_dc":
                        throw new NotImplementedException("RiQuest data service not yet implemented for srw_dc format.");
                    case "info_ofi":
                        throw new NotImplementedException("RiQuest data service not yet implemented for info_ofi format.");
                    case "rqi":
                        EnableXmlAttribute.XSLTransform = "";
                        break;
                    case "rq":
                        EnableXmlAttribute.XSLTransform = "~/xslt/rqi2rq.xslt";
                        break;
                    default:
                        throw new NotImplementedException("RiQuest data service not implemented for unknown format.");
                }
                StateStorage.States viewState = (!string.IsNullOrEmpty(queryString) && (queryString.StartsWith("$class$") == true)) ? StateStorage.States.BrowseViewState : StateStorage.States.ListViewState;
                return View("ServRQItem", GetModel(queryString == null ? GetQuery(viewState) : NewQuery(queryString, viewState)));
            }
            else
                return View("Index");
        }

        /// <summary>
        /// Controller action answering POST http-requests to RQItems.
        /// </summary>
        /// <param name="queryString">
        /// Accepted values are character strings conforming to the RiQuest query language. 
        /// </param>
        /// <param name="newRQItem">
        /// </param>
        /// <param name="verb">
        /// </param>
        /// <returns>
        /// </returns>
        [EnableJson, EnableXml]
        [HttpPost, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        [ValidateInput(false)]
        public ActionResult RQItemList(string verb, string queryString, RQItem newRQItem)
        {
            if ((!string.IsNullOrEmpty(verb)) && ((verb.ToLower() == "new") || (verb == RQResources.Views.Shared.SharedStrings.add)))
            {
                RQItem rqitem = null;

                if (ModelState.IsValid)
                {
                    try
                    {
                        RQItemModel model = GetModel(string.IsNullOrEmpty(queryString) ? GetQuery(StateStorage.States.EditState) : NewQuery(queryString, StateStorage.States.EditState), true);

                        rqitem = model.Add(newRQItem);
                        model.Update();
                    }
                    catch (Exception)
                    { }
                    return RQItemRecord((verb == "") ? verb : "edit", rqitem.DocNo, null);
                }
                return View("Index");
            }
            else
            {
                if (!string.IsNullOrEmpty(queryString)) NewQuery(queryString, (queryString.StartsWith("$class$") == true) ? Helpers.StateStorage.States.BrowseViewState : Helpers.StateStorage.States.ListViewState);
                return View("Index");
            }
        }
        
        /// <summary>
        /// Controller action answering GET http-requests to {serviceId}/RQItems/{rqitemID}.
        /// </summary>
        /// <remarks>
        /// The action reacts to URLs of type "~/{serviceId}/RQItems/{rqitemID}".
        /// The action request is filtered through the ActionFilterAttributes EnableJson and EnableXml:
        /// If the client GET request contains dataType=application/json | text/json or dataType=application/xml | text/xml the action response is generated by class JsonResult2 or XmlResult of MvpRestApiLib.
        /// In both cases the client is responsible to render the xml (f. e. by XSLT).
        /// Otherwise the action response is tranformed on the server according to the serviceId specified. 
        /// </remarks>
        /// <param name="verb">
        /// verb == rqSingleHTML: resets serviceId to "rq".
        /// verb == Edit: allows editing of database record.
        /// </param>
        /// <param name="serviceId">
        /// Id of desired sercive API:
        /// "rqi" = internal RiQuest API (default);
        /// "rq" = RiQuest proprietary exchange format;
        /// "mods" = Metadata Object Description Format (MODS) API of the Library of Congress (not yet supported);
        /// "oai_dc" = Dublin Core(DC) API serving metadata according to the specification of Open Archives Initiative (OAI);
        /// "srw_dc" = Dublin Core(DC) API serving metadata according to the specification of the Search / Retrieve Web Service (SRW) (not yet supported);
        /// "info_ofi" = OpenURL API (not yet supported);
        /// "pubmed" = API serving metadata according to the PubMed metadata scheme (not yet supported).
        /// </param>
        /// <param name="rqitemId">
        /// DocNo of RQItem to be returned.
        /// </param>
        /// <returns>
        /// The action returns the single RQItem with DocNo=rqitemID as */json, */xml response or text/html response - the latter formatted according to SingleRQItemView - depending on data types specified in the GET request.  
        /// </returns>
        [EnableJson, EnableXml]
        [HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        public ActionResult RQItemRecord(string verb, string rqitemId, string serviceId )
        {
            string view = "DisplRQItem";
            RQItem rqitem = GetModel(NewQuery("$access$" + rqitemId, Helpers.StateStorage.States.ItemViewState)).RQItems.FirstOrDefault(p => p.DocNo == rqitemId);

            if (rqitem != null)
            {
                if (verb == null) verb = "";
                switch (verb.ToLower())
                {
                    case "rqsinglehtml":
                        serviceId = "rqi";
                        break;
                    case "edit":
                        view = "EditRQitem";
                        ViewBag.EditButton1 = RQResources.Views.Shared.SharedStrings.update;
                        ViewBag.EditButton2 = RQResources.Views.Shared.SharedStrings.cancel;
                        break;
                    case "copy":
                        view = "EditRQitem";
                        ViewBag.EditButton1 = RQResources.Views.Shared.SharedStrings.add;
                        ViewBag.EditButton2 = RQResources.Views.Shared.SharedStrings.cancel;
                        rqitem = new RQItem(rqitem._resultItem);
                        rqitem.ID = "";
                        rqitem.DocNo = "";
                        break;
                    default:
                        break;
                }
                if (!string.IsNullOrEmpty(serviceId))
                {
                    ViewBag.ServiceType = serviceId;
                    ViewBag.TextSeg0 = "an individual RQItem";
                    view = "ServRQItem";
                    switch (serviceId)
                    {
                        case "mods":
                            throw new NotImplementedException("RiQuest data service not yet implemented for mods format.");
                        case "oai_dc":
                            EnableXmlAttribute.XSLTransform = "~/xslt/rqi2dc.xslt";
                            break;
                        case "srw_dc":
                            throw new NotImplementedException("RiQuest data service not yet implemented for srw_dc format.");
                        case "info_ofi":
                            throw new NotImplementedException("RiQuest data service not yet implemented for info_ofi format.");
                        case "rqi":
                            EnableXmlAttribute.XSLTransform = "";
                            break;
                        case "rq":
                            EnableXmlAttribute.XSLTransform = "~/xslt/rqi2rq.xslt";
                            break;
                        default:
                            throw new NotImplementedException("RiQuest data service not yet implemented for unknown format.");
                    }
                }
                else
                    EnableXmlAttribute.XSLTransform = "";
                return View(view, rqitem);
            }
            else
                throw new NotImplementedException("Could not find a RiQuest item with requested document number.");
        }
 
        // POST /RQItems
        // Add a new RQItem.
        [EnableJson, EnableXml]
        [HttpPost, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        [ValidateInput(false)]
        [ActionName("RQItemRecord")]
        public ActionResult UpdateItem(string verb, string rqitemId, string serviceId, RQItem changeRQItem)
        {
            RQItemModel model = null;
            RQItem rqitem = null;

            if (!ModelState.IsValid)
                return View();
            if ((rqitemId != null) && (rqitemId != ""))
            {
                try
                {
                    model = GetModel(NewQuery("$access$" + rqitemId, Helpers.StateStorage.States.ItemViewState), true);
                    rqitem = model.RQItems.FirstOrDefault(p => p.DocNo == rqitemId);
                    if ((verb.ToLower() == "update") || (verb == RQResources.Views.Shared.SharedStrings.update))
                        rqitem.Change(changeRQItem);
                    else if ((verb.ToLower() == "new") || (verb == RQResources.Views.Shared.SharedStrings.add))
                        rqitem = model.Add(changeRQItem);
                    else if ((verb.ToLower() == "delete") || (verb == RQResources.Views.Shared.SharedStrings.delete))
                    { } // not yet implemented
                    else if ((verb.ToLower() == "cancel") || (verb == RQResources.Views.Shared.SharedStrings.cancel))
                        verb = "";
                    model.Update();
                }
                catch (Exception)
                {};
            }
            return RQItemRecord((verb == "") ? verb : "edit", rqitem.DocNo, serviceId);
        }

        /// <summary>
        /// Controller action answering GET http-requests to /RQItems/{rqitemID}/{fieldName}.
        /// </summary>
        /// <remarks>
        /// The action reacts to URLs of type "~/RQItems/{rqitemID}/{fieldName}".
        /// The action request is filtered through the ActionFilterAttributes EnableJson and EnableXml:
        /// If the client GET request contains dataType=application/json | text/json or dataType=application/xml | text/xml the action response is generated by class JsonResult2 or XmlResult of MvpRestApiLib.
        /// In both cases the client is responsible to render the xml (f. e. by XSLT).
        /// Otherwise the action response is tranformed on the server according to the XXX-View. 
        /// </remarks>
        /// <param name="rqitemId">
        /// DocNo of RQItem to be used.
        /// </param>
        /// <param name="fieldName">
        /// Name of ItemAplphanumeric string with name of ItemDescElement: f. e. Classification
        /// </param>
        /// <param name="subFieldIndex">
        /// Index of the required subfield of the ItemDescElement.
        /// </param>
        /// <returns>
        /// The action returns the ItemDescElement with FieldName = descElementId of RQItem with DocNo=rqitemId as */json, */xml response or text/html response - the latter formatted according to DescElementView - depending on data types specified in the GET request.  
        /// </returns>
        [EnableJson, EnableXml]        
        [HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]        
        public ActionResult RQItemDescElement(string rqitemId, string fieldName, string subFieldIndex)
        {
            if (!string.IsNullOrEmpty(fieldName) && !string.IsNullOrEmpty(rqitemId) )
            {
                try
                {
                    RQItemModel model = GetModel(GetQuery(Helpers.StateStorage.States.ItemViewState)); 
                    RQItem rqitem = model.RQItems.FirstOrDefault(p => p.DocNo == rqitemId);
                    if (rqitem == null)
                    {
                        model = GetModel(NewQuery("$access$" + rqitemId, Helpers.StateStorage.States.ItemViewState));
                        rqitem = model.RQItems.FirstOrDefault(p => p.DocNo == rqitemId); // rqitem not available by query saved in state storage  
                    }
                    return View("ServIndRQItem", rqitem.GetField(fieldName, System.Convert.ToInt16(subFieldIndex)));
                }
                catch (Exception)
                {
                    throw;
                };
            }
            return null;
        }

        #endregion
    }
}
