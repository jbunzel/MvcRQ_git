using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using MvcRQ.Models;
using MvpRestApiLib;
using System.Web.UI;

using RQLib.RQQueryForm;

namespace MvcRQ.Controllers
{

    /// <summary>
    /// Controller Class for URLs designating RQItem objects
    /// </summary>
    /// <remarks>
    /// The controller supports URLs of type 
    /// {formatID}RQItems/{RQItemId}
    /// </remarks>
    public class RQItemsController : Controller
    {

        /// <summary>
        /// Returns a collection of RQItems pertainig to a given query. 
        /// </summary>
        /// <remarks>
        /// A RQQuery structure is generated from the given query string. The default properties of RQQuery have to be set in advance.
        /// The query result is retrieved from the server-side cache, if one has already been stored under the same query string 
        /// </remarks>
        /// <param name="queryString">
        /// A query string input conforming to Riquest query syntax.  
        /// </param>
        /// <returns>
        /// The RQItemModel with RQItems property containing the result list. 
        /// </returns>
        private RQItemModel GetModel( string queryString)
        {
            RQquery query = RQLib.RQStateManager.RQSessionState.RQQueryState.GetQueryState(queryString);
            var rqitemModel = base.HttpContext.Cache[query.QueryString.ToLower()] as RQItemModel; 

            if (rqitemModel == null)
            {
                if (query.QueryBookmarks == false)
                    query.QueryBookmarks = true;
                rqitemModel = new RQItemModel(query);
                base.HttpContext.Cache[query.QueryString.ToLower()] = rqitemModel;
            }
            return rqitemModel;
        }


        /// <summary>
        /// Controller action answering GET http-requests to RQItems
        /// </summary>
        /// <remarks>
        /// The action reacts to URLs of type "~/RQItems".
        /// The action response is filtered by the ActionFilterAttributes "EnableJson" and "EnableXml":
        /// If the GET request contains dataType=application/json | text/json or dataType=application/xml | text/xml the action response is generated by class "JsonResult2" or "XmlResult" of "MvpRestApiLib".
        /// In both cases the client is responsible to render the xml (f. e. by XSLT).
        /// Otherwise the action response is transformed to text/html on the server according to the value of parameter "verb". 
        /// </remarks>
        /// <param name="verb">
        /// null | new | rqListHTML.
        /// </param>
        /// <returns>
        /// verb == null: The action returns the (empty) RQItems/Index view.
        /// verb == new: The action returns an (empty) data entry mask to add a new RQItem (not yet implemented).
        /// verb == rqListHTML: The action returns a collection of RQItems as */json, */xml or text/html - the latter generated by the XSLT "RQResultList2RQSorted.xslt" - depending on data types specified in the GET request.
        /// The returned collection is the result set pertaining either to the last query stored in the state storage or - if no query is stored - to the "recent additions" query. 
        /// </returns>
        [EnableJson, EnableXml]
        [HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        public ActionResult Index(string verb)
        {
            if (verb == "New")
                return View("NewRQItem", new RQItem());
            else if (verb == null)
                return View(); // This view lets the client load the default result list by a another GET http-request to RQItems with verb="rqListHTML". 
            else
                return this.Content(GetModel("").toHTML(verb), "text/html", System.Text.Encoding.UTF8);
        }


        /// <summary>
        /// Controller action answering GET http-requests to {formatID}/RQItems
        /// </summary>
        /// <remarks>
        /// The action reacts to URLs of type "~/{formatID}/RQItems".
        /// The action request is filtered through the ActionFilterAttributes EnableJson and EnableXml:
        /// If the client GET request contains dataType=application/json | text/json or dataType=application/xml | text/xml the action response is generated by class JsonResult2 or XmlResult of MvpRestApiLib.
        /// In both cases the client is responsible to render the xml (f. e. by XSLT).
        /// Otherwise the action response is tranformed on the server according to the formatID specified. 
        /// </remarks>
        /// <param name="rqitemId">
        /// DocNo of RQItem to be returned.
        /// </param>
        /// <param name="formatId">
        /// Id of desired xml format:
        /// "rq" = RQIntern format (default);
        /// "mods" = Metadata Object Description Format (MODS) of the Library of Congress (not yet supported);
        /// "oai_dc" = Dublin Core(DC) metadata scheme according to the specification of Open Archives Initiative (OAI);
        /// "srw_dc" = Dublin Core(DC) metadata scheme according to the specification of the Search / Retrieve Web Service (SRW) (not yet supported);
        /// "info_ofi" = OpenURL metadata scheme (not yet supported);
        /// "pubmed" = PubMed metadata scheme (not yet supported).
        /// </param>
        /// <returns>
        /// The action returns */json, */xml or text/html response - the latter being formatted according to SingleRQItemView - depending on data types specified in the GET request. 
        /// </returns>
        [EnableJson, EnableXml]
        [HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        public ActionResult RQItemList(string formatId)
        {
            RQItemSet rqitemset = GetModel("").RQItems;
            System.Xml.XmlTextReader r = rqitemset.ConvertTo(formatId);

            try 
	        {
                r.MoveToContent();
                return this.Content(r.ReadOuterXml(), "text/xml", System.Text.Encoding.UTF8);
	        }
	        catch (Exception)
	        {
                // Occurs with empty result set for "recent additions".
                throw;
	        }
        }


        /// <summary>
        /// Controller action answering GET http-requests to {formatID}/RQItems/rqitemID.
        /// </summary>
        /// <remarks>
        /// The action reacts to URLs of type "~/{formatID}/RQItems/rqitemID".
        /// The action request is filtered through the ActionFilterAttributes EnableJson and EnableXml:
        /// If the client GET request contains dataType=application/json | text/json or dataType=application/xml | text/xml the action response is generated by class JsonResult2 or XmlResult of MvpRestApiLib.
        /// In both cases the client is responsible to render the xml (f. e. by XSLT).
        /// Otherwise the action response is tranformed on the server according to the formatID specified. 
        /// </remarks>
        /// <param name="rqitemId">
        /// DocNo of RQItem to be returned.
        /// </param>
        /// <param name="formatId">
        /// Id of desired xml format:
        /// "rq" = RQIntern format (default);
        /// "mods" = Metadata Object Description Format (MODS) of the Library of Congress (not yet supported);
        /// "oai_dc" = Dublin Core(DC) metadata scheme according to the specification of Open Archives Initiative (OAI);
        /// "srw_dc" = Dublin Core(DC) metadata scheme according to the specification of the Search / Retrieve Web Service (SRW) (not yet supported);
        /// "info_ofi" = OpenURL metadata scheme (not yet supported);
        /// "pubmed" = PubMed metadata scheme (not yet supported).
        /// </param>
        /// <returns>
        /// The action returns the single RQItem with DocNo=rqitemID as */json, */xml response or text/html response - the latter formatted according to SingleRQItemView - depending on data types specified in the GET request.  
        /// </returns>
        [EnableJson, EnableXml]
        [HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        public ActionResult RQItemRecord(string rqitemId, string formatId)
        {
            RQItem rqitem = GetModel("").RQItems.FirstOrDefault(p => p.DocNo == rqitemId);
            if (rqitem == null) rqitem = GetModel("$access$" + rqitemId).RQItems.FirstOrDefault(p => p.DocNo == rqitemId); // rqitem not available by query saved in state storage  
            if (formatId != null)
            {
                System.Xml.XmlTextReader r = rqitem.ConvertTo(formatId);

                r.MoveToContent();
                return this.Content(r.ReadOuterXml(), "text/xml", System.Text.Encoding.UTF8);
            }
            else
                return View("SingleRQItem", rqitem);
        }


        /// <summary>
        /// Controller action answering POST http-requests to RQItems.
        /// </summary>
        /// <param name="queryString">
        /// Accepted values are character strings conforming to the RiQuest query language. 
        /// </param>
        /// <returns>
        /// </returns>
        [EnableJson, EnableXml]
        [HttpPost, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        [ActionName("Index")]
        public ActionResult SearchRQItem(string queryString)
        {
            return View(GetModel(queryString).RQItems);
        }
        

        //// POST /RQItems
        //// Add a new RQItem.
        //[EnableJson, EnableXml]
        //[HttpPost, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        //[ActionName("Index")]
        //public ActionResult AddNewRQItem(RQItem newRQItem)
        //{
        //    List<RQItem> rqitems = new List<RQItem>(GetModel().RQItems);
        //    newRQItem.ID = "CUS" + (rqitems.Count + 1).ToString("0000");
        //    rqitems.Add(newRQItem);
        //    GetModel().RQItems = rqitems;

        //    return RedirectToAction("SingleRQItem", new { rqitemId = newRQItem.ID });
        //}

        //// GET /RQItems/00001
        //// Return a single rqitem data.
        //[EnableJson, EnableXml(XSLTransform = "/xslt/RQ2DC.xslt")]
        //[HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        //public ActionResult SingleRQItem(string rqitemId)
        //{
        //    RQItem rqitem = GetModel().RQItems.FirstOrDefault(p => p.DocNo == rqitemId); 

        //    return View("SingleRQItem", rqitem);
        //}


        //// DELETE /RQItems/CUS0001
        //// Delete a single rqitem.
        //[EnableJson, EnableXml]
        //[HttpDelete]
        //[ActionName("SingleRQItem")]
        //public ActionResult SingleRQItemDelete(string rqitemId)
        //{
        //    List<RQItem> rqitems = new List<RQItem>(GetModel().RQItems);
        //    rqitems.Remove(rqitems.Find(c => c.ID == rqitemId));
        //    GetModel().RQItems = rqitems;
        //    return RedirectToAction("Index", "RQItems");
        //}

        //// POST /RQItems/CUS0001(?verb=Delete)
        //// Update/Delete a single rqitem
        //[HttpPost]
        //[EnableJson, EnableXml]
        //public ActionResult SingleRQItem(RQItem changeRQItem, string rqitemId, string verb)
        //{
        //    if (verb == "Delete")
        //    {
        //        return SingleRQItemDelete(rqitemId);
        //    }
        //    else
        //    {
        //        if (ModelState.IsValid)
        //        {
        //            var existingRQItem = GetModel().RQItems.First(c => c.ID == rqitemId);
        //            existingRQItem.Title = changeRQItem.Title;
        //            existingRQItem.Location = changeRQItem.Locality;

        //            ViewData["Message"] = "Saved";
        //            return SingleRQItem(rqitemId);
        //        }
        //        else
        //        {
        //            throw new ApplicationException("Invalid model state");
        //        }
        //    }            
        //}

        //// GET /RQItems/CUS0001/ItemDescElements(/ORD0001)
        //// Return rqitem itemdescelements. If itemdescelementId specified, then return a single itemdescelement.
        //[EnableJson, EnableXml]        
        //[HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]        
        //public ActionResult SingleRQItemItemDescElements(string rqitemId, string itemdescelementId)
        //{
        //    if (!string.IsNullOrEmpty(itemdescelementId))
        //        return View("SingleRQItemSingleItemDescElement", GetModel()
        //            .RQItems.First(c => c.ID == rqitemId)
        //            .ItemDescElements.First(o => o.ID == itemdescelementId));
        //    else
        //        return View("SingleRQItemItemDescElements", GetModel()
        //            .RQItems.First(c => c.ID == rqitemId)
        //            .ItemDescElements);

        //}

        //// POST /RQItems/CUS0001/ItemDescElements/ORD0001(?verb=Delete)
        //// Update/Delete a single itemdescelement.
        //[HttpPost]
        //[EnableJson, EnableXml]
        //public ActionResult SingleRQItemItemDescElements(ItemDescElement changedItemDescElement, string rqitemId, string itemdescelementId, string verb)
        //{
        //    if (verb == "Delete")
        //    {
        //        var rqitem = GetModel().RQItems.First(c => c.ID == rqitemId);
        //        List<ItemDescElement> itemdescelements = new List<ItemDescElement>(rqitem.ItemDescElements);
        //        itemdescelements.Remove(itemdescelements.Find(o => o.ID == itemdescelementId));
        //        rqitem.ItemDescElements = itemdescelements;
        //        return RedirectToAction("SingleRQItem", "RQItems", new { rqitemId = rqitemId });
        //    }            
        //    else 
        //    {
        //        if (ModelState.IsValid)
        //        {
        //            var existingItemDescElement = GetModel().RQItems.First(c => c.ID == rqitemId)
        //                .ItemDescElements.First(o => o.ID == itemdescelementId);
        //            existingItemDescElement.Name = changedItemDescElement.Name;
        //            existingItemDescElement.Value1 = changedItemDescElement.Value1;
        //            existingItemDescElement.Value1 = changedItemDescElement.Value1;

        //            ViewData["Message"] = "Saved";
        //            return SingleRQItemItemDescElements(rqitemId, itemdescelementId);
        //        }
        //        else
        //        {
        //            throw new ApplicationException("Invalid model state");
        //        }
        //    }            
        //}
        
    }

}
