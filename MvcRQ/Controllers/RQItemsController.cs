using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using MvcRQ.Models;
using MvpRestApiLib;
using System.Web.UI;

using RQLib.RQQueryForm;

namespace MvcRQ.Controllers
{

    /// <summary>
    /// Controller Class for URLs designating RQItem objects
    /// </summary>
    /// <remarks>
    /// The controller supports URLs of type 
    /// {serviceId}RQItems/{RQItemId}
    /// </remarks>
    public class RQItemsController : Controller
    {

        /// <summary>
        /// Returns a collection of RQItems pertainig to a given query. 
        /// </summary>
        /// <remarks>
        /// A RQQuery structure is generated from the given query string. The default properties of RQQuery have to be set in advance.
        /// The query result is retrieved from the server-side cache, if one has already been stored under the same query string 
        /// </remarks>
        /// <param name="queryString">
        /// A query string input conforming to Riquest query syntax.  
        /// </param>
        /// <returns>
        /// The RQItemModel with RQItems property containing the result list. 
        /// </returns>
        private RQItemModel GetModel( string queryString)
        {
            RQquery query = RQLib.RQStateManager.RQSessionState.RQQueryState.GetQueryState(queryString);
            var rqitemModel = base.HttpContext.Cache[query.QueryString.ToLower()] as RQItemModel; 

            if (rqitemModel == null)
            {
                if (query.QueryBookmarks == false)
                    query.QueryBookmarks = true;
                rqitemModel = new RQItemModel(query);
                base.HttpContext.Cache[query.QueryString.ToLower()] = rqitemModel;
            }
            return rqitemModel;
        }
        
        private string TransformModel ( RQItemModel model, string format, int fromItem, int toItem)
        {
            System.Xml.XmlTextReader r = model.RQItems.ConvertTo(format, fromItem, toItem);

            try
            {
                var xTrf = new System.Xml.Xsl.XslCompiledTransform();
                var xTrfArg = new System.Xml.Xsl.XsltArgumentList();
                var mstr = new System.Xml.XmlTextWriter(new System.IO.MemoryStream(), System.Text.Encoding.UTF8);
                var doc = new System.Xml.XmlDocument();

                r.MoveToContent();
                xTrf.Load(Server.MapPath("~/xslt/ViewTransforms/RQResultList2RQSorted.xslt"));
                xTrfArg.AddParam("ApplPath", "", "http://" + Request.ServerVariables.Get("HTTP_HOST") + (Request.ApplicationPath.Equals("/") ? "" : Request.ApplicationPath) );
                xTrf.Transform(new System.Xml.XPath.XPathDocument(r), xTrfArg, mstr);
                mstr.BaseStream.Flush();
                mstr.BaseStream.Seek(0, System.IO.SeekOrigin.Begin);
                doc.Load(mstr.BaseStream);

                //TESTDATEI EZEUGEN
                //doc.Save("C:/MVCTest.xml");
                //mstr.BaseStream.Seek(0, System.IO.SeekOrigin.Begin);

                var rd = new System.Xml.XmlTextReader(mstr.BaseStream);
                return doc.OuterXml;
            }
            catch
            {
                // RQItemSet ist leer
                return "";
            }
        }

        /// <summary>
        /// Controller action answering GET http-requests to RQItems
        /// </summary>
        /// <remarks>
        /// The action reacts to URLs of type "~/RQItems".
        /// The action response is filtered by the ActionFilterAttributes "EnableJson" and "EnableXml":
        /// If the GET request contains dataType=application/json | text/json or dataType=application/xml | text/xml the action response is generated by class "JsonResult2" or "XmlResult" of "MvpRestApiLib".
        /// In both cases the client is responsible to render the xml (f. e. by XSLT).
        /// Otherwise the action response is transformed to text/html on the server according to the value of parameter "verb". 
        /// </remarks>
        /// <param name="verb">
        /// null | new | rqListHTML.
        /// </param>
        /// <returns>
        /// verb == null: The action returns the (empty) RQItems/Index view.
        /// verb == new: The action returns an (empty) data entry mask to add a new RQItem (not yet implemented).
        /// verb == rqListHTML: The action returns a collection of RQItems as */json, */xml or text/html - the latter generated by the XSLT "RQResultList2RQSorted.xslt" - depending on data types specified in the GET request.
        /// The returned collection is the result set pertaining either to the last query stored in the state storage or - if no query is stored - to the "recent additions" query. 
        /// </returns>
        [EnableJson, EnableXml]
        [HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        public ActionResult Index(string verb, string query)
        {
            if (verb == "New")
                return View("NewRQItem", new RQItem());
            else if (verb == "rqListHTML")
                return this.Content(TransformModel(GetModel(query == null ? "" : query), verb, 1, 0), "text/html", System.Text.Encoding.UTF8);
            else
                return View("Index", GetModel(query == null ? "" : query).RQItems); 

        }


        /// <summary>
        /// Controller action answering GET http-requests to {serviceId}/RQItems
        /// </summary>
        /// <remarks>
        /// The action reacts to URLs of type "~/{serviceId}/RQItems".
        /// The action request is filtered through the ActionFilterAttributes EnableJson and EnableXml:
        /// If the client GET request contains dataType=application/json | text/json or dataType=application/xml | text/xml the action response is generated by class JsonResult2 or XmlResult of MvpRestApiLib.
        /// In both cases the client is responsible to render the xml (f. e. by XSLT).
        /// Otherwise the action response is tranformed on the server according to the serviceId specified. 
        /// </remarks>
        /// <param name="serviceId">
        /// Id of desired sercive API:
        /// "rq" = internal RiQuest API (default);
        /// "mods" = Metadata Object Description Format (MODS) API of the Library of Congress (not yet supported);
        /// "oai_dc" = Dublin Core(DC) API serving metadata according to the specification of Open Archives Initiative (OAI);
        /// "srw_dc" = Dublin Core(DC) API serving metadata according to the specification of the Search / Retrieve Web Service (SRW) (not yet supported);
        /// "info_ofi" = OpenURL API (not yet supported);
        /// "pubmed" = API serving metadata according to the PubMed metadata scheme (not yet supported).
        /// </param>
        /// <param name="verb">
        /// verb == rqListHTML: The action returns a collection of RQItems as */json, */xml or text/html - the latter generated by the XSLT "RQResultList2RQSorted.xslt" - depending on data types specified in the GET request.
        /// </param>
        /// <returns>
        /// The action returns */json, */xml or text/html response - the latter being formatted according to SingleRQItemView - depending on data types specified in the GET request. 
        /// </returns>
        [EnableJson, EnableXml]
        [HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        public ActionResult RQItemList(string serviceId, string verb, string query)
        {
            string view = "ServListRQItem";

            if (verb == "rqListHTML") return Index(verb, query == null ? "" : query); 
            if (serviceId != null)
            {
                ViewBag.ServiceType = serviceId;
                switch (serviceId)
                {
                    case "mods":
                        throw new NotImplementedException("RiQuest data service not yet implemented for mods format.");
                    case "oai_dc":
                        EnableXmlAttribute.XSLTransform = "~/xslt/rq2dc1.xslt";
                        break;
                    case "srw_dc":
                        throw new NotImplementedException("RiQuest data service not yet implemented for srw_dc format.");
                    case "info_ofi":
                        throw new NotImplementedException("RiQuest data service not yet implemented for info_ofi format.");
                    case "rq":
                        EnableXmlAttribute.XSLTransform = "";
                        break;
                    default:
                        throw new NotImplementedException("RiQuest data service not implemented for unknown format.");
                }
            }
            else
                EnableXmlAttribute.XSLTransform = "";
            return View(view, GetModel(query == null ? "" : query).RQItems);
        }


        /// <summary>
        /// Controller action answering GET http-requests to {serviceId}/RQItems/rqitemID.
        /// </summary>
        /// <remarks>
        /// The action reacts to URLs of type "~/{serviceId}/RQItems/rqitemID".
        /// The action request is filtered through the ActionFilterAttributes EnableJson and EnableXml:
        /// If the client GET request contains dataType=application/json | text/json or dataType=application/xml | text/xml the action response is generated by class JsonResult2 or XmlResult of MvpRestApiLib.
        /// In both cases the client is responsible to render the xml (f. e. by XSLT).
        /// Otherwise the action response is tranformed on the server according to the serviceId specified. 
        /// </remarks>
        /// <param name="rqitemId">
        /// DocNo of RQItem to be returned.
        /// </param>
        /// <param name="serviceId">
        /// Id of desired sercive API:
        /// "rq" = internal RiQuest API (default);
        /// "mods" = Metadata Object Description Format (MODS) API of the Library of Congress (not yet supported);
        /// "oai_dc" = Dublin Core(DC) API serving metadata according to the specification of Open Archives Initiative (OAI);
        /// "srw_dc" = Dublin Core(DC) API serving metadata according to the specification of the Search / Retrieve Web Service (SRW) (not yet supported);
        /// "info_ofi" = OpenURL API (not yet supported);
        /// "pubmed" = API serving metadata according to the PubMed metadata scheme (not yet supported).
        /// </param>
        /// <param name="verb">
        /// verb == rqSingleHTML: resets serviceId to "rq".
        /// </param>
        /// <returns>
        /// The action returns the single RQItem with DocNo=rqitemID as */json, */xml response or text/html response - the latter formatted according to SingleRQItemView - depending on data types specified in the GET request.  
        /// </returns>
        [EnableJson, EnableXml]
        [HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        public ActionResult RQItemRecord(string rqitemId, string serviceId, string verb)
        {
            string view = "IndRQItem";
            RQItem rqitem = GetModel("").RQItems.FirstOrDefault(p => p.DocNo == rqitemId);

            if (rqitem == null) rqitem = GetModel("$access$" + rqitemId).RQItems.FirstOrDefault(p => p.DocNo == rqitemId); // rqitem not available by query saved in state storage  
            if (verb == "rqSingleHTML") serviceId = "rq";
            if (serviceId != null)
            {
                ViewBag.ServiceType = serviceId;
                switch (serviceId)
                {
                    case "mods":
                        throw new NotImplementedException("RiQuest data service not yet implemented for mods format.");
                    case "oai_dc":
                        EnableXmlAttribute.XSLTransform = "~/xslt/rq2dc1.xslt";
                        view = "ServIndRQItem";
                        break;
                    case "srw_dc":
                        throw new NotImplementedException("RiQuest data service not yet implemented for srw_dc format.");
                    case "info_ofi":
                        throw new NotImplementedException("RiQuest data service not yet implemented for info_ofi format.");
                    case "rq":
                        EnableXmlAttribute.XSLTransform = "";
                        view = "ServIndRQItem";
                        break;
                    default:
                        throw new NotImplementedException("RiQuest data service not yet implemented for unknown format.");
                }
            }
            else
                EnableXmlAttribute.XSLTransform = "";
            return View(view, rqitem);
        }


        /// <summary>
        /// Controller action answering POST http-requests to RQItems.
        /// </summary>
        /// <param name="queryString">
        /// Accepted values are character strings conforming to the RiQuest query language. 
        /// </param>
        /// <returns>
        /// </returns>
        [EnableJson, EnableXml]
        [HttpPost, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        [ActionName("Index")]
        public ActionResult SearchRQItem(string queryString)
        {
            return View("Index",GetModel(queryString).RQItems);
        }


        protected override void OnException(ExceptionContext filterContext)
        {
            if (filterContext.HttpContext.IsCustomErrorEnabled || true)  //IsCustomErrorEnabled always false if client is localhost or client and server IPs identical. True set to override.
            {
                filterContext.ExceptionHandled = true;            
                // If this is an ajax request, return the exception in the response            
                if (filterContext.HttpContext.Request.IsAjaxRequest())
                {
                    filterContext.HttpContext.Response.StatusCode = 500;
                    var json = new JsonResult();
                    json.Data = filterContext.Exception.Message + filterContext.Exception.StackTrace;
                    json.ExecuteResult(this.ControllerContext);
                }
                else
                {
                    ViewData.Model = new System.Web.Mvc.HandleErrorInfo(filterContext.Exception,"ControllerName", "ActionName");
                    // Pass a flag to the view to tell it whether or not to show a the stack trace                
                    ViewBag.IsCustomErrorEnabled = true; //filterContext.HttpContext.IsCustomErrorEnabled;
                    this.View("Error").ExecuteResult(this.ControllerContext);
                }
            }
        }

        // POST /RQItems
        // Add a new RQItem.
        [EnableJson, EnableXml]
        [HttpPost, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        [ActionName("RQItemRecord")]
        [ValidateInput(false)]
        public ActionResult UpdateItem(FormCollection form, string verb)
        {
            // binding post to RQItem does not work for some reason unknown. Using FormCollection is recommended to protect against data tampering. 
            string rqitemId = form["DocNo"];

            if (rqitemId != "")
            {
                try
                {
                    RQItemModel model = GetModel(""); 
                    RQItem rqitem = model.RQItems.FirstOrDefault(p => p.DocNo == rqitemId);
                    if (rqitem == null)
                    {
                        model = GetModel("$access$" + rqitemId);
                        rqitem = model.RQItems.FirstOrDefault(p => p.DocNo == rqitemId); // rqitem not available by query saved in state storage  
                    }
                    rqitem.Change(form);
                    model.Update();
                }
                catch (Exception)
                {
                    throw;
                };
            }
            return null;
        }

        //// GET /RQItems/00001
        //// Return a single rqitem data.
        //[EnableJson, EnableXml(XSLTransform = "/xslt/RQ2DC.xslt")]
        //[HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]
        //public ActionResult SingleRQItem(string rqitemId)
        //{
        //    RQItem rqitem = GetModel().RQItems.FirstOrDefault(p => p.DocNo == rqitemId); 

        //    return View("SingleRQItem", rqitem);
        //}


        //// DELETE /RQItems/CUS0001
        //// Delete a single rqitem.
        //[EnableJson, EnableXml]
        //[HttpDelete]
        //[ActionName("SingleRQItem")]
        //public ActionResult SingleRQItemDelete(string rqitemId)
        //{
        //    List<RQItem> rqitems = new List<RQItem>(GetModel().RQItems);
        //    rqitems.Remove(rqitems.Find(c => c.ID == rqitemId));
        //    GetModel().RQItems = rqitems;
        //    return RedirectToAction("Index", "RQItems");
        //}

        //// POST /RQItems/CUS0001(?verb=Delete)
        //// Update/Delete a single rqitem
        //[HttpPost]
        //[EnableJson, EnableXml]
        //public ActionResult SingleRQItem(RQItem changeRQItem, string rqitemId, string verb)
        //{
        //    if (verb == "Delete")
        //    {
        //        return SingleRQItemDelete(rqitemId);
        //    }
        //    else
        //    {
        //        if (ModelState.IsValid)
        //        {
        //            var existingRQItem = GetModel().RQItems.First(c => c.ID == rqitemId);
        //            existingRQItem.Title = changeRQItem.Title;
        //            existingRQItem.Location = changeRQItem.Locality;

        //            ViewData["Message"] = "Saved";
        //            return SingleRQItem(rqitemId);
        //        }
        //        else
        //        {
        //            throw new ApplicationException("Invalid model state");
        //        }
        //    }            
        //}

        //// GET /RQItems/CUS0001/ItemDescElements(/ORD0001)
        //// Return rqitem itemdescelements. If itemdescelementId specified, then return a single itemdescelement.
        //[EnableJson, EnableXml]        
        //[HttpGet, OutputCache(NoStore = true, Location = OutputCacheLocation.None)]        
        //public ActionResult SingleRQItemItemDescElements(string rqitemId, string itemdescelementId)
        //{
        //    if (!string.IsNullOrEmpty(itemdescelementId))
        //        return View("SingleRQItemSingleItemDescElement", GetModel()
        //            .RQItems.First(c => c.ID == rqitemId)
        //            .ItemDescElements.First(o => o.ID == itemdescelementId));
        //    else
        //        return View("SingleRQItemItemDescElements", GetModel()
        //            .RQItems.First(c => c.ID == rqitemId)
        //            .ItemDescElements);

        //}

        //// POST /RQItems/CUS0001/ItemDescElements/ORD0001(?verb=Delete)
        //// Update/Delete a single itemdescelement.
        //[HttpPost]
        //[EnableJson, EnableXml]
        //public ActionResult SingleRQItemItemDescElements(ItemDescElement changedItemDescElement, string rqitemId, string itemdescelementId, string verb)
        //{
        //    if (verb == "Delete")
        //    {
        //        var rqitem = GetModel().RQItems.First(c => c.ID == rqitemId);
        //        List<ItemDescElement> itemdescelements = new List<ItemDescElement>(rqitem.ItemDescElements);
        //        itemdescelements.Remove(itemdescelements.Find(o => o.ID == itemdescelementId));
        //        rqitem.ItemDescElements = itemdescelements;
        //        return RedirectToAction("SingleRQItem", "RQItems", new { rqitemId = rqitemId });
        //    }            
        //    else 
        //    {
        //        if (ModelState.IsValid)
        //        {
        //            var existingItemDescElement = GetModel().RQItems.First(c => c.ID == rqitemId)
        //                .ItemDescElements.First(o => o.ID == itemdescelementId);
        //            existingItemDescElement.Name = changedItemDescElement.Name;
        //            existingItemDescElement.Value1 = changedItemDescElement.Value1;
        //            existingItemDescElement.Value1 = changedItemDescElement.Value1;

        //            ViewData["Message"] = "Saved";
        //            return SingleRQItemItemDescElements(rqitemId, itemdescelementId);
        //        }
        //        else
        //        {
        //            throw new ApplicationException("Invalid model state");
        //        }
        //    }            
        //}
        
    }

}
